id   : ∀a. a → a
f    : ∀a. (a → a) → a → a
succ : Int → Int
pair : ∀a. ∀b. a → b → (a × b)
map  : ∀a. ∀b. (a → b) → [a] → [b]

1) id 1
2) f succ
3) f (λx. x)
4) pair (λx. x) 0



----------------------------------------------------------------------
--+                                                                +--
--+                              id 1                              +--
--+                                                                +--
----------------------------------------------------------------------


Γ := id : ∀a. a → a


                                                         Δ = (Γ , â := Int)                                  
                                                    ------------------------- S-Ex-R
                              Γ, â ⊢ Top ⇒ 1 ⇒ Int      Γ, â ⊢ Int <: â ⊣ Δ ↪ Int      Δ/s ⊢ Int <: Top ⊣ Δ/s ↪ Int
                             ----------------------------------------------------------------------------------- S-Inst
                              Γ, â ⊢ â → â <: [1] → Top ⊣ Δ ↪ Int → Int
                             --------------------------------------------- S-All-L
Γ ⊢ Top ⇒ id ⇒ ∀a. a → a      Γ ⊢ ∀a. a → a <: [1] → Top ⊣ Γ ↪ Int → Int
----------------------------------------------------------------------------- T-Sub
Γ ⊢ [1] → Top ⇒ id ⇒ Int → Int
-----------------------------------  T-App
Γ ⊢ Top ⇒ id 1 ⇒ Int


----------------------------------------------------------------------
--+                                                                +--
--+                             f succ                             +--
--+                                                                +--
----------------------------------------------------------------------

Γ := f : ∀a. (a → a) → a → a, succ : Int → Int


                                                                      Γ, â ⊢ â <: Int ⊣ Γ, â := Int ↪ Int
                                                                      ------------------------------------------------------------------
                                         Γ, â ⊢ Top ⇒ succ ⇒ Int → Int     Γ, â ⊢ Int → Int <: (â → â) ⊣ Δ ↪ Int → Int  
                                         --------------------------------------------------------------------------------------------- S-Inst
                                          Γ, â ⊢ (â → â) → â → â <: [succ] → Top ⊣ Δ\s  ↪ (Int → Int) → Int → Int
                                         -------------------------------------------------------------------- S-All-L
Γ ⊢ Top ⇒ f ⇒ ∀a. (a → a) → a → a         Γ ⊢ ∀a. (a → a) → a → a <: [succ] → Top ⊣ Δ\s ↪ (Int → Int) → Int → Int
------------------------------------------------------------------------------------------------------------------- T-Sub
Γ ⊢ [succ] → Top ⇒ f ⇒ (Int → Int) → Int → Int
----------------------------------------------- T-App
Γ ⊢ Top ⇒ f succ ⇒ Int → Int



----------------------------------------------------------------------
--+                                                                +--
--+                           f (λx.x)                            +--
--+                                                                +--
----------------------------------------------------------------------

Γ := ∀a. (a → a) → a → a

                                         ------------------------------------------------- IMPOSSIBLE 
                                         Γ, â ⊢ (â → â) → â → â <: [λx.x] → Top ⊣ Δ ↪ _
                                        --------------------------------------------------------
Γ ⊢ Top ⇒ f ⇒ ∀a. (a → a) → a → a        Γ ⊢  ∀a. (a → a) → a → a <: [λx.x] → Top ⊣ Δ ↪ _
----------------------------------------------------------------------------------------------- T-Sub
Γ ⊢ [λx.x] → Top ⇒ f ⇒ _
---------------------------------------- T-App
Γ ⊢ Top ⇒ f (λx.x) ⇒ _





-----------      -------------
⊢ Int <: â ~   â := Int       ⊢ â <: □
----------------------------------------
â ⊢ â → â <: [1] → □ ⊣ 
-----------------------------
⊢ ∀ a. a → a <: [1] → □


â ⊢ Int → Int <: â → â ⊣ â := Int     â := Int ⊢ â → â <: □ ⊣ 
------------------------------------------------------------------
â ⊢ (â → â) → (â → â) <: [succ] → □
---------------------------------------
⊢ ∀ a. (a → a) → (a → a) <: [succ] → □



There'll be a case:

* □ is Nothing
* it describes a situtation we have solution in context 

â := Int ⊢ â → â <: □ ⊣ â := Int ~> Int → Int

there's two options to refine a type:

1. introduce a "context subsitution":
   it'll a new operation (maybe hard to reason) in our system, the concern is that
   it finds all free variables in a type, then find solution in a context and then subsitute it.

2. give serveral rules for □ (can be viewed as we're trying to split □)
   and delegate the refining phase to base rules:

  ----------------------------------------- base-□
   Γ ⊢ â <: □ ⊣ Γ ~> (find/subst ^a in Γ)           <---- much simpler since it involves single var


  ----------------- base-□-int
   Γ ⊢ Int <: □ ~> Int


   Γ ⊢ A <: □ ⊣ Δ₁ ~> A'      Δ₁ ⊢ B <: □ ⊣ Δ₂ ~> B' 
   --------------------------------------------- arrow-□
   Γ ⊢ A → B <: □ ⊣ Δ ~> A' → B'


   Γ, a ⊢ A <: □ ⊣ Δ ~> A'
   --------------------------
   Γ ⊢ ∀a.A <: □ ⊣ Δ ~> ∀a. A'






  ----------------------------------------- base-□
   Γ ⊢ â ~> (find/subst ^a in Γ)  


  ----------------- base-□-int
   Γ ⊢ Int ~> Int


   Γ ⊢ A ~> A'      Γ ⊢ B ~> B' 
   --------------------------------------------- arrow-□
   Γ ⊢ A → B ~> A' → B'


   Γ, a ⊢ A ~> A'
   --------------------------
   Γ ⊢ ∀a.A  ~> ∀a. A'

(F succ)


