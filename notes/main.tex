\def\OPTIONConf{0}%
\def\OPTIONArxiv{0}%
%
\documentclass{article}
\usepackage{fullpage}

\usepackage{mathpartir}

\usepackage{amsthm}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}

\usepackage{amsmath}
\usepackage{marvosym}  % for \Pointinghand / \Hand in llproof

\usepackage{srcltx}
\usepackage{goodcharter}
\usepackage{euler}

\usepackage{jdunfield}
\usepackage{llproof}
\usepackage{rulelinks}

% strike through
\usepackage{soul}


\newcommand{\macroname}[1]{\texttt{\Backslash}\textvtt{#1}}

\newcommand{\unitty}{\tyname{1}}
\newcommand{\rulename}[1]{\textsf{#1}}
\newcommand{\elabtyperulename}[1]{\rulename{\textcolor{dDigPurple}{E#1}}}

\newrulecommand{EVar}{\elabtyperulename{var}}


\title{Generlizing Bidirecitonal Typing}

\author{Xu Xue}


\begin{document}
\maketitle

\section{Declarative System}

\begin{align*}
&\text{Types} \quad\quad &A, B ::=&~ \mathtt{Int} \mid \mathtt{Top} \mid A \rightarrow B\\
&\text{Expressions} \quad \quad &e::=&~ x \mid \lambda x . ~e \mid e_1~e_2 \mid e : A\\
&\text{Contexts} \quad\quad &\Gamma::=&~ . \mid \Gamma, x : A
\end{align*}

The second application rule is declarative \footnote{it differs from the original interpretation of bi-directional typing that targets for algorithmic system} and not mode-correct since we need to guess the type $B$, with only partial information $A$. However, we can prove that it is implementable. We need to justify two cases: $(\lambda f. f~1 : (\mathtt{Int} \rightarrow \mathtt{Int}))~(\lambda x.~x)$ and $(\lambda x.~x)~1$.

\begin{mathpar}
\inferrule*[lab=T-App1]
{\Gamma \vdash e_1 \Rightarrow A \rightarrow B \\
 \Gamma \vdash e_2 \Leftarrow A}
{\Gamma \vdash e_1~e_2 \Rightarrow B}


\inferrule*[lab=T-App2]
{\Gamma \vdash e_1 \Leftarrow A \rightarrow B \\
 \Gamma \vdash e_2 \Rightarrow A}
{\Gamma \vdash e_1~e_2 \Rightarrow B}
\end{mathpar}

\section{Algorithmic System}

\subsection{Syntax}

\begin{align*}
&\text{Types} \quad\quad &A, B ::=&~ \mathtt{Int} \mid \mathtt{Top} \mid A \rightarrow B \mid \boxed{e}\\
&\text{Expressions} \quad \quad &e::=&~ x \mid \lambda x . ~e \mid e_1~e_2 \mid e : A\\
&\text{Contexts} \quad\quad &\Gamma::=&~ . \mid \Gamma, x : A
\end{align*}

\subsection{Typing}

We introduce the typing judgment $\Gamma \vdash A \Rightarrow e \Rightarrow B$. It accepts three inputs: a context $\Gamma$, a checking type $A$ and an expression $B$ and returns an inferred type $B$.

\begin{mathpar}
\inferrule*[lab=T-Lit]
{\Gamma \vdash \mathtt{Int} <: A}
{\Gamma \vdash A \Rightarrow i \Rightarrow \mathsf{Int}}

\inferrule*[lab=T-Var]
{x : B \in \Gamma \\
 \Gamma \vdash B <: A}
{\Gamma \vdash A \Rightarrow x \Rightarrow B}

\inferrule*[lab=T-App]
{\Gamma \vdash \boxed{e_2} \rightarrow A \Rightarrow e_1 \Rightarrow C \rightarrow D}
{\Gamma \vdash A \Rightarrow e_1~e_2 \Rightarrow D}

\inferrule*[lab=T-Ann]
{\Gamma \vdash B \Rightarrow e \Rightarrow B \\
 \Gamma \vdash B <: A}
{\Gamma \vdash A \Rightarrow e : B \Rightarrow B}

\inferrule*[lab=T-Lam1]
{\Gamma \vdash \mathtt{Top} \Rightarrow e_1 \Rightarrow A \\
 \Gamma, x : A \vdash B \Rightarrow e \Rightarrow B'}
{\Gamma \vdash \boxed{e_1} \rightarrow B \Rightarrow \lambda x.~e \Rightarrow A \rightarrow B'}

\inferrule*[lab=T-Lam2]
{\Gamma, x : A \vdash B \Rightarrow e \Rightarrow B'}
{\Gamma \vdash A \rightarrow B \Rightarrow \lambda x.~e \Rightarrow A \rightarrow B'}

\inferrule*[lab=T-Lam3]
{ }
{\Gamma \vdash \mathtt{Top} \Rightarrow \lambda x.~e \Rightarrow A \rightarrow B}
\end{mathpar}

\subsection{Subtyping}

Typing and subtyping are mutually dependent. There's an observation that $\boxed{e}$ will only appear on the left of the subtyping.

\begin{mathpar}
\inferrule*[lab=S-Refl]	
{ }
{\Gamma \vdash \mathtt{Int} <: \mathtt{Int}}

\inferrule*[lab=S-Top]
{ }
{\Gamma \vdash A <: \mathtt{Top}}

\inferrule*[lab=S-Arr]
{\Gamma \vdash C <: A \\
 \Gamma \vdash B <: D}
{\Gamma \vdash A \rightarrow B <: C \rightarrow D}

\inferrule*[lab=S-Tele]
{\Gamma \vdash A \Rightarrow e \Rightarrow A'}
{\Gamma \vdash \boxed{e} <: A}

\end{mathpar}

\section{Examples}

\subsection{$(\lambda f . ~ f ~ 1) : ((Int \rightarrow Int) \rightarrow Int)~ (\lambda x. ~x)$}

This case only uses the T-Lam2 case, which is similar to the check mode for the $\lambda.x ~e$. ($\lambda x.~x$ cannot infer a type thus it skips the T-Lam1).

\begin{mathpar}
\small
\inferrule*[Right=T-App]
%%%%%% T-App Premise
{
\inferrule*[Right=T-Ann]
{
\inferrule*[Right=T-Lam2]{ }{. \vdash (Int \rightarrow Int) \rightarrow Int \Rightarrow \lambda f . ~ f ~ 1 \Rightarrow (Int \rightarrow Int) \rightarrow Int} \quad \quad \quad \quad
\inferrule*[Right=S-Arr]{ }{. \vdash (Int \rightarrow Int) \rightarrow Int <: \boxed{\lambda x. ~x} \rightarrow Top}
}
{. \vdash \boxed{\lambda x. ~x} \rightarrow Top \Rightarrow (\lambda f . ~ f ~ 1) : ((Int \rightarrow Int) \rightarrow Int) \Rightarrow (Int \rightarrow Int) \rightarrow Int}
}
%%%%%% T-App Conclusion
{. \vdash Top \Rightarrow (\lambda f . ~ f ~ 1) : ((Int \rightarrow Int) \rightarrow Int)~ (\lambda x. ~x) \Rightarrow Int}
\end{mathpar}

\noindent For the second premise, we have

\begin{mathpar}
\inferrule*[Right=S-Arr]
{
\inferrule*[Right=S-Tele]
{. \vdash Int \rightarrow Int \Rightarrow \lambda x. ~x \Rightarrow Int \rightarrow Int}
{ . \vdash \boxed{\lambda x. ~x} <: Int \rightarrow Int} \\
. \vdash Int <: Top
}
{. \vdash (Int \rightarrow Int) \rightarrow Int <: \boxed{\lambda x. ~x} \rightarrow Top}
\end{mathpar}


\subsection{$(\lambda x. ~x)~1$}

This case is used in ``let arguments go first", where the type of arguments can be known.

\begin{mathpar}
\inferrule*[Right=T-App]
{
\inferrule*[Right=T-Lam1]
{. \vdash Top \Rightarrow 1 \Rightarrow Int \\ x : Int \vdash Top \Rightarrow x \Rightarrow Int}
{. \vdash \boxed{1} \rightarrow Top \Rightarrow \lambda x. ~x \Rightarrow Int \rightarrow Int}
}
{. \vdash Top \Rightarrow (\lambda x. ~x)~1 \Rightarrow Int}
\end{mathpar}




\section{Metatheory}

\begin{lemma}[Generlizing infer mode]
$\Gamma \vdash e \Rightarrow A \cong \Gamma \vdash \mathtt{Top} \Rightarrow e \Rightarrow A$
\end{lemma}

\begin{lemma}[Generlizing check mode]
$\Gamma \vdash e \Leftarrow A \cong \Gamma \vdash A \Rightarrow e \Rightarrow A'$
\end{lemma}

\section{Problems Identified}

\begin{enumerate}
	\item $\Gamma \vdash \mathtt{Top} \Rightarrow e \Rightarrow A'$ breaks the Lemma 2, since checked by \texttt{Top} tells us nothing and we cannot ensure it must infer a type.
	\item \st{The metatheory only tells that it subsumes the traditional bidirectional typing, but it hasn't shown that we can infer more types}.
	\item We need to find a way to normalize/categorize the type, otherwise, we will get the final inferred type which is \boxed{e}.
\end{enumerate}

\section{Related work}

Dunfield's bidirectional typing mentioned concluded this is a simultaneous input and output.


\end{document}


% Local Variables: 
% mode: latex
% TeX-master: example
% End: 
