We are looking for a spec that precisely captures the programs that our algorithm accepts.
We have first tried:

```
T |- e <= A -> B         T |- e => A
---------------------------
T |- e => B
```

But this turns out to be too powerful, as illustrated by the program:

```
(\x. \y. y) 1
```


which can infer multiple types, such as `Int -> Int` or `Bool -> Bool`.
Basically we will eventually try to check a lambda without any type information,
giving us freedom to assign multiple types to the lambda. 

Note that

```
(\x. \y. y) 1 2
```

would be ok, inferring `Int`, because now there are 2 arguments that will
provide necessary type information to check the lambdas.

The idea for the spec is that we need to make sure that when checking lambdas
type information for the argument must be there. This can be done by tracking
a number that counts the number of available type argument information.

Our counter is defined as:

j ::= . | n

`.` means that all the information is available.
`n` means that we know the information about `n` type arguments.

With this, we can have a lambda rule like:

```
T, x : A |-(j-) e <= B 
-----------------
T |-j \x . e <= A -> B
```

where the operation `j-` is defined as:

```
.-     = .
(S n) = n
```

The key point is that if `j = 0` then the rule above fails (i.e. the function is not defined for 0).
If `j =0`, we know that the `A` that is being used in the rule is guessed, not given by some previous annotation
or some argument inference.

The set of full rules are:

=========
T |-j e <=> A
=========

```
x : A in T
----------
T |-j x => A 

T |-j i => Int

T, x : A |-(j-) e <= B 
-----------------
T |-j \x . e <= A -> B

T |-. e <= A
-------------
T |-j (e : A) => A

T |-j e1 => A -> B          T |-. e2 <= A
-------------------------------
T |-j e1 e2 => B

T |-(j+) <= A -> B          T |-0 e2 => A
-------------------------------
T |-j e1 e2 => B

T |-j e => A           A <: B
--------------------
T |-j <= B
```

Notes:

- The operation (j+) increments the counter in the obvious way: `(.+)=.` and `(n+) = n+1`
- In the rule where we infer the argument we increase the counter, since know we know
one more argument.
- Other rules and premises just have to make sure that the counter information is correctly
propagated.


Now, with the above rules we are able to prevent the problematic example:

```
fails! ==> we ran out of arguments
---------------
x : Int |-0 \y. y <= ?
--------------------
. |-1 \x . \y. y => Int -> ?               . |-0 1 => Int 
--------------------------------------
. |-0 (\x . \y. y) 1 => ?
```

If instead we had:

```
x : Int, y : Int |-0 y => Int
----------------------
x : Int |-1 \y.y => Int -> Int
--------------------------
. |-2 \x . \y. y => Int -> Int -> Int               . |-0 1 => Int 
--------------------------------------------
. |-1 (\x . \y. y) 1 => Int -> Int               . |-0 2 => Int 
--------------------------------------
. |-0 ((\x . \y. y) 1) 2 => Int
```
