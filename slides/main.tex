\documentclass[compress,12pt,aspectratio=169]{beamer}

\usepackage{mathpartir}
\usepackage{amsmath}
\usepackage{mathtools}

\usetheme[frameno,sans]{Arguelles}

\title{Contextual Type Inference}

\author{Xu Xue}

\begin{document}

\frame[plain]{\titlepage}

\begin{frame} 
\tableofcontents
\end{frame}

\section{Declarative System}

\begin{frame}{Syntax}

\begin{align*}
&\text{Types} \quad\quad &A, B ::=&~ \mathtt{Int} \mid \mathtt{Top} \mid A \rightarrow B\\
&\text{Expressions} \quad \quad &e::=&~ x \mid \lambda x . ~e \mid e_1~e_2 \mid e : A\\
&\text{Contexts} \quad\quad &\Gamma::=&~ . \mid \Gamma, x : A
\end{align*}

\end{frame}

\begin{frame}{Bidirectional Typing: \boxed{\Gamma \vdash e \Leftrightarrow A}}
\begin{mathpar}
\inferrule*[lab=T-Lit]
{ }
{\Gamma \vdash n \Rightarrow Int}

\inferrule*[lab=T-Var]
{x : A \in \Gamma}
{\Gamma \vdash x \Rightarrow A}

\inferrule*[lab=T-Lam]
{\Gamma, x : A \vdash e \Leftarrow B}
{\Gamma \vdash \lambda x.~e \Leftarrow A \rightarrow B}

\inferrule*[lab=T-App1]
{\Gamma \vdash e_1 \Rightarrow A \rightarrow B \\
 \Gamma \vdash e_2 \Leftarrow A}
{\Gamma \vdash e_1~e_2 \Rightarrow B}

\inferrule*[lab=T-App2]
{\Gamma \vdash e_1 \Leftarrow A \rightarrow B \\
 \Gamma \vdash e_2 \Rightarrow A}
{\Gamma \vdash e_1~e_2 \Rightarrow B}

\inferrule*[lab=T-Ann]
{\Gamma \vdash e \Leftarrow A}
{\Gamma \vdash e : A \Rightarrow A}

\inferrule*[lab=T-Sub]
{\Gamma \vdash e \Rightarrow B \\ B <: A}
{\Gamma \vdash e \Leftarrow A}
\end{mathpar}
\end{frame}

\begin{frame}{Subtyping: \boxed{A <: B}}
\begin{mathpar}
\inferrule*[lab=S-Int]
{ }
{Int <: Int}

\inferrule*[lab=S-Top]
{ }
{A <: Top}

\inferrule*[lab=S-Arr]
{C <: A \\ B <: D}
{A \rightarrow B <: C \rightarrow D}
\end{mathpar}
    
\end{frame}

\section{Algorithmic System}
\begin{frame}{Syntax}
\begin{align*}
&\text{Types with Holes}\quad\quad &A*, B* ::=&~ \mathtt{Int} \mid \mathtt{Top} \mid A* \rightarrow B* \mid \boxed{e}\\
&\text{Types} \quad\quad &A, B ::=&~ \mathtt{Int} \mid \mathtt{Top} \mid A \rightarrow B\\
&\text{Expressions} \quad \quad &e::=&~ x \mid \lambda x . ~e \mid e_1~e_2 \mid e : A\\
&\text{Contexts} \quad\quad &\Gamma::=&~ . \mid \Gamma, x : A
\end{align*}    
\end{frame}

\begin{frame}{Typing: \boxed{\Gamma \vdash A* \Rightarrow e \Rightarrow A}}
\begin{mathpar}
\small
\inferrule*[lab=T-Lit]
{\Gamma \vdash \mathtt{Int} <: A*}
{\Gamma \vdash A* \Rightarrow i \Rightarrow \mathsf{Int}}

\inferrule*[lab=T-Var]
{x : B \in \Gamma \\
 \Gamma \vdash B <: A*}
{\Gamma \vdash A* \Rightarrow x \Rightarrow B}

\inferrule*[lab=T-App]
{\Gamma \vdash \boxed{e_2} \rightarrow A* \Rightarrow e_1 \Rightarrow C \rightarrow D}
{\Gamma \vdash A* \Rightarrow e_1~e_2 \Rightarrow D}

\inferrule*[lab=T-Ann]
{\Gamma \vdash B \Rightarrow e \Rightarrow B \\
 \Gamma \vdash B <: A*}
{\Gamma \vdash A* \Rightarrow e : B \Rightarrow B}

\inferrule*[lab=T-Lam1]
{\Gamma \vdash \mathtt{Top} \Rightarrow e_1 \Rightarrow A \\
 \Gamma, x : A \vdash B* \Rightarrow e \Rightarrow B}
{\Gamma \vdash \boxed{e_1} \rightarrow B* \Rightarrow \lambda x.~e \Rightarrow A \rightarrow B}

\inferrule*[lab=T-Lam2]
{\Gamma, x : A \vdash B* \Rightarrow e \Rightarrow C}
{\Gamma \vdash A \rightarrow B* \Rightarrow \lambda x.~e \Rightarrow A \rightarrow C}
\end{mathpar}    
\end{frame}

\begin{frame}{Second look of the rules}

T-Lam2 only appear after the annotation, and the type hint should be normal. Should we consider it in some application mode? I don't think so, since application mode should be in the form of

$$
\Gamma \vdash \boxed{e_2} \rightarrow A* \Rightarrow e_1 \Rightarrow A
$$

I manage to syntactically (maybe hint, maybe term) understand these rules

Consider replace it with (note that hint are normal types)

\begin{mathpar}
\inferrule*[lab=T-Lam2]
{\Gamma, x : A \vdash B \Rightarrow e \Rightarrow C}
{\Gamma \vdash A \rightarrow B \Rightarrow \lambda x.~e \Rightarrow A \rightarrow C}
\end{mathpar}

	
\end{frame}

\begin{frame}{Second look of the rules}
Type with holes could be more specific (we discussed before), and I think it's time to settle it.

\textbf{Observation:}, hints are either normal types or chaining terms ending with a $\star$ \footnote{considered as isomorphic to $Top$}.

\begin{align*}
&\text{Holes}\quad\quad &O ::=&~ \star \mid \boxed{e} \rightarrow \star\\
&\text{Normal Types} \quad\quad &A, B ::=&~ \mathtt{Int} \mid \mathtt{Top} \mid A \rightarrow B\\
&\text{Hints} \quad \quad &H ::=&~ O \mid A
\end{align*}    


Sorry, this is a wrong observation..	
\end{frame}

\begin{frame}{Subtyping: \boxed{\Gamma \vdash A* <: B*}}
\begin{mathpar}
\inferrule*[lab=S-Refl]	
{ }
{\Gamma \vdash \mathtt{Int} <: \mathtt{Int}}

\inferrule*[lab=S-Top]
{ }
{\Gamma \vdash A* <: \mathtt{Top}}

\inferrule*[lab=S-Arr]
{\Gamma \vdash C* <: A* \\
 \Gamma \vdash B* <: D*}
{\Gamma \vdash A* \rightarrow B* <: C* \rightarrow D*}

\inferrule*[lab=S-Tele]
{\Gamma \vdash A \Rightarrow e \Rightarrow A}
{\Gamma \vdash \boxed{e} <: A}
\end{mathpar}    
\end{frame}


\section{Alternative Algo}

\begin{frame}{Syntax}
\begin{align*}
&\text{Hints}\quad\quad &H ::=&~ A \mid \boxed{e} \mapsto H\\
&\text{Normal Types} \quad\quad &A, B ::=&~ \mathtt{Int} \mid \mathtt{Top} \mid A \rightarrow B
\end{align*}

I'm trying to think could it have something like
$$
\boxed{e} \rightarrow A \rightarrow \boxed{e} \rightarrow ... or \quad A \rightarrow \boxed{e} \rightarrow ...
$$

I don't think so, since there're several ways to modify the hint

\begin{itemize}
	\item Lambda, only eliminate the head
	\item Ann, replace the whole hint by a normal type (annotation)
	\item App, chain/append a hole on top of a hint
\end{itemize}


\end{frame}

\begin{frame}{Typing: \boxed{\Gamma \vdash H \Rightarrow e \Rightarrow A}}
\begin{mathpar}
\small
\inferrule*[lab=T-Lit]
{\Gamma \vdash \mathtt{Int} <: H}
{\Gamma \vdash H \Rightarrow i \Rightarrow \mathsf{Int}}

\inferrule*[lab=T-Var]
{x : B \in \Gamma \\
 \Gamma \vdash B <: H}
{\Gamma \vdash H \Rightarrow x \Rightarrow B}

\inferrule*[lab=T-App]
{\Gamma \vdash \boxed{e_2} \mapsto H \Rightarrow e_1 \Rightarrow A \rightarrow B}
{\Gamma \vdash H \Rightarrow e_1~e_2 \Rightarrow B}

\inferrule*[lab=T-Ann]
{\Gamma \vdash B \Rightarrow e \Rightarrow B \\
 \Gamma \vdash B <: H}
{\Gamma \vdash H \Rightarrow e : B \Rightarrow B}

\inferrule*[lab=T-Lam1]
{\Gamma \vdash \mathtt{Top} \Rightarrow e_1 \Rightarrow A \\
 \Gamma, x : A \vdash H \Rightarrow e \Rightarrow B}
{\Gamma \vdash \boxed{e_1} \mapsto H \Rightarrow \lambda x.~e \Rightarrow A \rightarrow B}

\inferrule*[lab=T-Lam2]
{\Gamma, x : A \vdash B \Rightarrow e \Rightarrow C}
{\Gamma \vdash A \rightarrow B \Rightarrow \lambda x.~e \Rightarrow A \rightarrow C}
\end{mathpar}    
\end{frame}

\begin{frame}{Subtyping: \boxed{\Gamma \vdash H_1 <: H_2}}
\begin{mathpar}
\inferrule*[lab=S-Refl]	
{ }
{\Gamma \vdash \mathtt{Int} <: \mathtt{Int}}

\inferrule*[lab=S-Top]
{ }
{\Gamma \vdash A <: \mathtt{Top}}

\inferrule*[lab=S-Arr]
{\Gamma \vdash C <: A \\
 \Gamma \vdash B <: D}
{\Gamma \vdash A \rightarrow B <: C \rightarrow D}

\inferrule*[lab=S-Chain]
{\Gamma \vdash \boxed{e} <: A	 \\
 \Gamma \vdash B <: H}
{\Gamma \vdash A \rightarrow B <: \boxed{e} \mapsto H}

\inferrule*[lab=S-Hole]
{\Gamma \vdash A \Rightarrow e \Rightarrow A}
{\Gamma \vdash \boxed{e} <: A}
\end{mathpar}    
\end{frame}

\section{Metatheory}

\begin{frame}{Soundness}
\begin{theorem}[Soundness]
If $\Gamma \vdash A* \Rightarrow e \Rightarrow B$, then $\Gamma \vdash e \Leftarrow B.$
\begin{proof}
Induction on algo typing:
\end{proof}
\end{theorem}
\end{frame}

\begin{frame}{Proof of Soundness}
\textbf{case lit}
\begin{itemize}
    \item goal: $\Gamma \vdash n \Leftarrow Int$
    \item apply T-Lit
\end{itemize}
\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
\textbf{case var}
\begin{itemize}
    \item goal: $\Gamma \vdash x \Leftarrow B$, given $x : B \in \Gamma$
    \item apply T-Sub and S-Refl
    \item apply T-Var
\end{itemize}
\end{frame}

\begin{frame}{Proof of Soundness (Cont.)}
\textbf{case app}
\begin{itemize}
    \item goal: $\Gamma \vdash e_1~e_2 \Leftarrow B$, given $\Gamma \vdash A \Rightarrow e_1~e_2 \Rightarrow B$
    \item which is $\Gamma \vdash \boxed{e_2} \rightarrow A \Rightarrow e_1 \Rightarrow C \rightarrow B$
    \item by induction hypo, we know that $\Gamma \vdash e_1 \Leftarrow C \rightarrow B$
    \item by subtyping property of algo typing, we know that $\Gamma \vdash \boxed{e_2} <: C$
\end{itemize}
\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
\begin{lemma}[Check Application]
If $\Gamma \vdash e_1 \Leftarrow A \rightarrow B$ and $\Gamma \vdash e_2 \Leftarrow A$, then $\Gamma \vdash e_1~e_2 \Leftarrow B$.
\end{lemma}
\begin{lemma}[Hole Subtyping and Check]
If 	$\Gamma \vdash \boxed{e} <: C$ ($C$ is a type), then $\Gamma \vdash e \Leftarrow C$.
\end{lemma}
\end{frame}

\begin{frame}{Proof of Lemma Check Application}
\begin{lemma}[Check Application]
If $\Gamma \vdash e_1 \Leftarrow A \rightarrow B$ and $\Gamma \vdash e_2 \Leftarrow A$, then $\Gamma \vdash e_1~e_2 \Leftarrow B$.
\end{lemma}
\begin{proof}
Induction on $\Gamma \vdash e_1 \Leftarrow A \rightarrow B$.
\end{proof}
\end{frame}

\begin{frame}{Proof of Lemma Check Application (Cont.)}
\textbf{case lam:}
\begin{itemize}
	\item goal: $\Gamma \vdash (\lambda x.~e)~e_2 \Leftarrow B$, given $\Gamma \vdash \lambda x. ~e \Leftarrow A \rightarrow B$ and $\Gamma \vdash e_2 \Leftarrow A$
	\item \textcolor{oc-red-8}{failed:} $\Gamma \vdash (\lambda x.~x)~(\lambda x.~x) \Leftarrow (Int \rightarrow Int)$
\end{itemize}
\end{frame}

\begin{frame}{Proof of Lemma Check Application (Cont.)}
\textbf{case sub:}
\begin{itemize}
	\item goal: $\Gamma \vdash e_1~e_2 \Leftarrow B$, given $\Gamma \vdash e_1 \Rightarrow C$, $C <: A \rightarrow B$ and $\Gamma \vdash e_2 \Leftarrow A$.
	\item that is $\Gamma \vdash e_1 \Rightarrow C_1 \rightarrow C_2$ and $C_1 \rightarrow C_2 <: A \rightarrow B$
	\item then we have $A <: C_1$ and $C_2 <: B$
	\item by lemma of check subsumption (?), we can have $\Gamma \vdash e_2 \Leftarrow C_1$
	\item apply T-App1, we get that $\Gamma \vdash e_1~e_2 \Leftarrow C_2$
	\item by lemma of check subsumption, we can prove the goal. 
\end{itemize}

\begin{lemma}[Check Subsumption]
If $\Gamma \vdash e \Leftarrow A$	and $A <: B$, then $\Gamma \vdash e \Leftarrow B$.
\end{lemma}
\end{frame}

\begin{frame}{Proof of Lemma Check Application (Cont.)}
Apparently, the check application lemma failed at case $(\lambda x.~x)~(\lambda x.~x)$, while it doesn't fail the soundness. I might find some inversion to forbid such cases (e.g., inversion on $e_1$ or $e_2$).

The problem becomes that to find the absurdity of cases like
	
$$
\Gamma \vdash \boxed{(\lambda x.~x)} \rightarrow Top \Rightarrow \lambda x.~x \Rightarrow (Int \rightarrow Int) \rightarrow (Int \rightarrow Int)
$$

It gives me the feeling like, forms $\Gamma \vdash \boxed{e_2} \rightarrow A \Rightarrow e_1 \Rightarrow B$, $e_1$ and $e_1$ cannot only be checked at the same time.
\end{frame}

\begin{frame}{Proof of Lemma Check Application (Cont.)}
Suddenly, I come up with the idea that in Neel and Dunfield's work (?), terms are classified into $Term^+$ and $Term^-$ to syntactically distinguish between inherited and synthesised types.

Then for applications, the well-typed will be $e^- ~ e^+$ or $e^+ ~ e^+$ or $e^+ ~ e^-$. 

Known issues: (1) explicit subsumption
\end{frame}

\section{Cases}

\begin{frame}{$(\lambda x. ~x)~1$}
\begin{mathpar}
\inferrule*[Right=T-App]
{
\inferrule*[Right=T-Lam1]
{. \vdash Top \Rightarrow 1 \Rightarrow Int \\ x : Int \vdash Top \Rightarrow x \Rightarrow Int}
{. \vdash \boxed{1} \rightarrow Top \Rightarrow \lambda x. ~x \Rightarrow Int \rightarrow Int}
}
{. \vdash Top \Rightarrow (\lambda x. ~x)~1 \Rightarrow Int}
\end{mathpar}
\end{frame}

\begin{frame}{$(\lambda f . ~ f ~ 1) : ((Int \rightarrow Int) \rightarrow Int)~ (\lambda x. ~x)$}

\begin{mathpar}
\scriptsize
\inferrule*[Right=T-App]
%%%%%% T-App Premise
{
\inferrule*[Right=T-Ann]
{
\inferrule*[Right=T-Lam2]{ }{. \vdash (Int \rightarrow Int) \rightarrow Int \Rightarrow \lambda f . ~ f ~ 1 \Rightarrow (Int \rightarrow Int) \rightarrow Int} \quad \quad \quad \quad
\inferrule*[Right=S-Arr]{ }{. \vdash (Int \rightarrow Int) \rightarrow Int <: \boxed{\lambda x. ~x} \rightarrow Top}
}
{. \vdash \boxed{\lambda x. ~x} \rightarrow Top \Rightarrow (\lambda f . ~ f ~ 1) : ((Int \rightarrow Int) \rightarrow Int) \Rightarrow (Int \rightarrow Int) \rightarrow Int}
}
%%%%%% T-App Conclusion
{. \vdash Top \Rightarrow (\lambda f . ~ f ~ 1) : ((Int \rightarrow Int) \rightarrow Int)~ (\lambda x. ~x) \Rightarrow Int}
\end{mathpar}

For the second premise, we have

\begin{mathpar}
\inferrule*[Right=S-Arr]
{
\inferrule*[Right=S-Tele]
{. \vdash Int \rightarrow Int \Rightarrow \lambda x. ~x \Rightarrow Int \rightarrow Int}
{ . \vdash \boxed{\lambda x. ~x} <: Int \rightarrow Int} \\
. \vdash Int <: Top
}
{. \vdash (Int \rightarrow Int) \rightarrow Int <: \boxed{\lambda x. ~x} \rightarrow Top}
\end{mathpar}
	
\end{frame}

\end{document}
