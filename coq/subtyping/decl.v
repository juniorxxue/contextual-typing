(* generated by Ott 0.32, locally-nameless lngen from: decl.ott *)
Require Import Bool.
Require Import Metalib.Metatheory.
Require Import List.
(** syntax *)
Definition typvar : Set := var.

Inductive typ : Set := 
 | typ_int : typ
 | typ_var_b (_:nat)
 | typ_var_f (X:typvar)
 | typ_arrow (A1:typ) (A2:typ)
 | typ_all (A:typ).

Inductive bind : Set := 
 | bind_empty : bind
 | bind_typ (A:typ).

Inductive counter : Set := 
 | counter_z : counter
 | counter_inf : counter
 | counter_suc (c:counter)
 | counter_tsuc (c:counter).

Definition env : Set := list (atom*bind).

(* EXPERIMENTAL *)
(** auxiliary functions on the new list types *)
(** library functions *)
(** subrules *)
(** arities *)
(** opening up abstractions *)
Fixpoint open_typ_wrt_typ_rec (k:nat) (A_5:typ) (A__6:typ) {struct A__6}: typ :=
  match A__6 with
  | typ_int => typ_int 
  | (typ_var_b nat) => 
      match lt_eq_lt_dec nat k with
        | inleft (left _) => typ_var_b nat
        | inleft (right _) => A_5
        | inright _ => typ_var_b (nat - 1)
      end
  | (typ_var_f X) => typ_var_f X
  | (typ_arrow A1 A2) => typ_arrow (open_typ_wrt_typ_rec k A_5 A1) (open_typ_wrt_typ_rec k A_5 A2)
  | (typ_all A) => typ_all (open_typ_wrt_typ_rec (S k) A_5 A)
end.

Definition open_bind_wrt_typ_rec (k:nat) (A5:typ) (b5:bind) : bind :=
  match b5 with
  | bind_empty => bind_empty 
  | (bind_typ A) => bind_typ (open_typ_wrt_typ_rec k A5 A)
end.

Definition open_bind_wrt_typ A5 b5 := open_bind_wrt_typ_rec 0 b5 A5.

Definition open_typ_wrt_typ A_5 A__6 := open_typ_wrt_typ_rec 0 A__6 A_5.

(** closing up abstractions *)
Fixpoint close_typ_wrt_typ_rec (k:nat) (A_5:var) (A__6:typ) {struct A__6}: typ :=
  match A__6 with
  | typ_int => typ_int 
  | (typ_var_b nat) => 
       if (lt_dec nat k) 
         then typ_var_b nat
         else typ_var_b (S nat)
  | (typ_var_f X) => if (A_5 === X) then (typ_var_b k) else (typ_var_f X)
  | (typ_arrow A1 A2) => typ_arrow (close_typ_wrt_typ_rec k A_5 A1) (close_typ_wrt_typ_rec k A_5 A2)
  | (typ_all A) => typ_all (close_typ_wrt_typ_rec (S k) A_5 A)
end.

Definition close_bind_wrt_typ_rec (k:nat) (A5:var) (b5:bind) : bind :=
  match b5 with
  | bind_empty => bind_empty 
  | (bind_typ A) => bind_typ (close_typ_wrt_typ_rec k A5 A)
end.

Definition close_bind_wrt_typ b5 A5 := close_bind_wrt_typ_rec 0 b5 A5.

Definition close_typ_wrt_typ A__6 A_5 := close_typ_wrt_typ_rec 0 A__6 A_5.

(** terms are locally-closed pre-terms *)
(** definitions *)

(* defns LC_typ *)
Inductive lc_typ : typ -> Prop :=    (* defn lc_typ *)
 | lc_typ_int : 
     (lc_typ typ_int)
 | lc_typ_var_f : forall (X:typvar),
     (lc_typ (typ_var_f X))
 | lc_typ_arrow : forall (A1 A2:typ),
     (lc_typ A1) ->
     (lc_typ A2) ->
     (lc_typ (typ_arrow A1 A2))
 | lc_typ_all : forall (A:typ),
      ( forall X , lc_typ  ( open_typ_wrt_typ A (typ_var_f X) )  )  ->
     (lc_typ (typ_all A)).

(* defns LC_bind *)
Inductive lc_bind : bind -> Prop :=    (* defn lc_bind *)
 | lc_bind_empty : 
     (lc_bind bind_empty)
 | lc_bind_typ : forall (A:typ),
     (lc_typ A) ->
     (lc_bind (bind_typ A)).
(** free variables *)
Fixpoint ftvar_in_typ (A_5:typ) : vars :=
  match A_5 with
  | typ_int => {}
  | (typ_var_b nat) => {}
  | (typ_var_f X) => {{X}}
  | (typ_arrow A1 A2) => (ftvar_in_typ A1) \u (ftvar_in_typ A2)
  | (typ_all A) => (ftvar_in_typ A)
end.

Definition ftvar_in_bind (b5:bind) : vars :=
  match b5 with
  | bind_empty => {}
  | (bind_typ A) => (ftvar_in_typ A)
end.

(** substitutions *)
Fixpoint subst_tvar_in_typ (A_5:typ) (X5:typvar) (A__6:typ) {struct A__6} : typ :=
  match A__6 with
  | typ_int => typ_int 
  | (typ_var_b nat) => typ_var_b nat
  | (typ_var_f X) => (if eq_var X X5 then A_5 else (typ_var_f X))
  | (typ_arrow A1 A2) => typ_arrow (subst_tvar_in_typ A_5 X5 A1) (subst_tvar_in_typ A_5 X5 A2)
  | (typ_all A) => typ_all (subst_tvar_in_typ A_5 X5 A)
end.

Definition subst_tvar_in_bind (A5:typ) (X5:typvar) (b5:bind) : bind :=
  match b5 with
  | bind_empty => bind_empty 
  | (bind_typ A) => bind_typ (subst_tvar_in_typ A5 X5 A)
end.


(** definitions *)

(* defns J_wf_typ *)
Inductive d_wf_typ : env -> typ -> Prop :=    (* defn d_wf_typ *)
 | wf_typ__int : forall (E:env),
     d_wf_typ E typ_int
 | wf_typ__tvar : forall (E:env) (X:typvar),
      binds ( X )  ( bind_empty ) ( E )  ->
     d_wf_typ E (typ_var_f X)
 | wf_typ__etvar : forall (E:env) (X:typvar) (A:typ),
      binds ( X )  ( (bind_typ A) ) ( E )  ->
     d_wf_typ E (typ_var_f X)
 | wf_typ__arrow : forall (E:env) (A1 A2:typ),
     d_wf_typ E A1 ->
     d_wf_typ E A2 ->
     d_wf_typ E (typ_arrow A1 A2)
 | wf_typ__all : forall (L:vars) (E:env) (A:typ),
      ( forall X , X \notin  L  -> d_wf_typ  ( X ~ bind_empty  ++  E )   ( open_typ_wrt_typ A (typ_var_f X) )  )  ->
     d_wf_typ E (typ_all A).

(* defns J_find *)
Inductive find : typvar -> counter -> typ -> Prop :=    (* defn find *)
 | find__zero : forall (X:typvar) (A:typ),
      X  `in` ftvar_in_typ  A  ->
     find X counter_z A
 | find__suc1 : forall (X:typvar) (c:counter) (A:typ),
      X  `in` ftvar_in_typ  A  ->
     find X (counter_suc c) A
 | find__suc2 : forall (X:typvar) (c:counter) (A B:typ),
     lc_typ A ->
     find X c B ->
     find X (counter_suc c) (typ_arrow A B)
 | find__suc3 : forall (L:vars) (X:typvar) (c:counter) (A:typ),
      ( forall Y , Y \notin  L  -> find X (counter_suc c)  ( open_typ_wrt_typ A (typ_var_f Y) )  )  ->
     find X (counter_suc c) (typ_all A)
 | find__tsuc1 : forall (L:vars) (X:typvar) (c:counter) (A:typ),
      ( forall Y , Y \notin  L  -> find X c  ( open_typ_wrt_typ A (typ_var_f Y) )  )  ->
     find X (counter_tsuc c) (typ_all A).

(* defns J_wf_env *)
Inductive wf_env : env -> Prop :=    (* defn wf_env *)
 | wf_env__empty : 
     wf_env  nil 
 | wf_env__tvar : forall (E:env) (X:typvar),
     wf_env E ->
      ( X   `notin` dom ( E ))  ->
     wf_env  ( X ~ bind_empty  ++  E ) 
 | wf_env__typ : forall (E:env) (X:typvar) (A:typ),
     wf_env E ->
     d_wf_typ E A ->
      ( X   `notin` dom ( E ))  ->
     wf_env  ( X ~ (bind_typ A)  ++  E ) .

(* defns J_d_inst *)
Inductive d_inst : env -> typ -> typ -> Prop :=    (* defn d_inst *)
 | d_inst__var : forall (E:env) (X:typvar) (B:typ),
      binds ( X )  ( (bind_typ B) ) ( E )  ->
     d_inst E (typ_var_f X) B
 | d_inst__int : forall (E:env),
     d_inst E typ_int typ_int
 | d_inst__arr : forall (E:env) (A1 A2 B1 B2:typ),
     d_inst E A1 B1 ->
     d_inst E A2 B2 ->
     d_inst E (typ_arrow A1 A2) (typ_arrow B1 B2)
 | d_inst__all : forall (L:vars) (E:env) (A B:typ),
      ( forall X , X \notin  L  -> d_inst E  ( open_typ_wrt_typ A (typ_var_f X) )   ( open_typ_wrt_typ B (typ_var_f X) )  )  ->
     d_inst E (typ_all A) (typ_all B).

(* defns J_d_sub *)
Inductive d_sub : env -> counter -> typ -> typ -> Prop :=    (* defn d_sub *)
 | d_sub__refl : forall (E:env) (A B:typ),
     wf_env E ->
     d_inst E A B ->
     d_sub E counter_z A B
 | d_sub__int : forall (E:env),
     wf_env E ->
     d_sub E counter_inf typ_int typ_int
 | d_sub__tvar : forall (E:env) (X:typvar),
     wf_env E ->
     d_sub E counter_inf (typ_var_f X) (typ_var_f X)
 | d_sub__arr1 : forall (E:env) (A1 B1 A2 B2:typ),
     d_sub E counter_inf A2 A1 ->
     d_sub E counter_inf B1 B2 ->
     d_sub E counter_inf (typ_arrow A1 B1) (typ_arrow A2 B2)
 | d_sub__arr2 : forall (E:env) (c:counter) (A1 B1 A2 B2:typ),
     d_sub E counter_inf A2 A1 ->
     d_sub E c B1 B2 ->
     d_sub E (counter_suc c) (typ_arrow A1 B1) (typ_arrow A2 B2)
 | d_sub__all : forall (L:vars) (E:env) (A1 A2:typ),
      ( forall X , X \notin  L  -> d_sub  ( X ~ bind_empty  ++  E )  counter_inf  ( open_typ_wrt_typ A1 (typ_var_f X) )   ( open_typ_wrt_typ A2 (typ_var_f X) )  )  ->
     d_sub E counter_inf (typ_all A1) (typ_all A2)
 | d_sub__alll1 : forall (L:vars) (E:env) (c:counter) (A B C:typ),
     d_wf_typ E C ->
      ( forall X , X \notin  L  -> find X (counter_suc c)  ( open_typ_wrt_typ A (typ_var_f X) )  )  ->
      ( forall X , X \notin  L  -> d_sub  ( X ~ (bind_typ C)  ++  E )  (counter_suc c)  ( open_typ_wrt_typ A (typ_var_f X) )  B )  ->
     d_sub E (counter_suc c) (typ_all A) B
 | d_sub__alll2 : forall (L:vars) (E:env) (c:counter) (A B C:typ),
     d_wf_typ E C ->
      ( forall X , X \notin  L  -> d_sub  ( X ~ (bind_typ C)  ++  E )  c  ( open_typ_wrt_typ A (typ_var_f X) )  B )  ->
     d_sub E (counter_tsuc c) (typ_all A) B
 | d_sub__varl : forall (E:env) (c:counter) (X:typvar) (A B:typ),
      binds ( X )  ( (bind_typ B) ) ( E )  ->
     d_sub E c B A ->
     d_sub E c (typ_var_f X) A
 | d_sub__varr : forall (E:env) (c:counter) (A:typ) (X:typvar) (B:typ),
      binds ( X )  ( (bind_typ B) ) ( E )  ->
     d_sub E c A B ->
     d_sub E c A (typ_var_f X).


(** infrastructure *)
#[export] Hint Constructors d_wf_typ find wf_env d_inst d_sub lc_typ lc_bind : core.


