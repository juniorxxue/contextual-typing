metavar typvar, X, Y, Z     ::= {{ repr-locally-nameless }}

grammar

typ, A, B, C, T    :: typ_ ::=
  | INT            ::   :: int
  | X              ::   :: var
  | A1 -> A2       ::   :: arrow
  | ∀ X . A        ::   :: all  (+ bind X in A +)
  | ( A )          :: S :: paren {{ coq ([[A]]) }}
  | { A2 / X } A1  :: M :: subst {{ coq (open_typ_wrt_typ [[X A1]] [[A2]]) }}

counter, c     :: counter_ ::=
  | z              ::  :: z
  | ∞              ::  :: inf
  | S c            ::  :: suc
  | St c           ::  :: tsuc

bind, b :: bind_ ::=
  | : ■  ::   :: empty
  | : A  ::   :: typ


substitutions
  single A X  :: subst_tvar_in

freevars
  A X  :: ftvar_in

grammar 

env, E :: '' ::= {{ coq list (atom*bind) }}
  | empty            ::   :: dempty {{ coq nil }}
  | E , X b          ::   :: dcons2 {{ coq ([[X]]~[[b]] ++ [[E]])  }}

formula :: formula_ ::=
  | judgement             ::   :: judgement
  | ( X b )  in E        ::   :: binds {{ coq binds ([[X]])  ([[b]]) ([[E]]) }}
  | X `notin` dom E  ::   :: fresh1 {{ coq ([[X]]  `notin` dom ([[E]])) }}


% formula :: formula_ ::=

defns
J_wf_typ :: '' ::=

defn
E |- A :: :: d_wf_typ :: 'wf_typ__' by

--------- :: int
E |- INT

(X : ■) in E
-------------- :: tvar
E |- X

(X : A) in E 
-------------- :: etvar 
E |- X

E |- A1
E |- A2
-------------- :: arrow
E |- A1 -> A2

E, X : ■ |- A
-------------------- :: all
E |- ∀ X . A


defns
J_wf_env :: '' ::=

defn
|- E :: :: wf_env :: 'wf_env__' by

--------- :: empty
|- empty

|- E
X `notin` dom E
---------------- :: tvar
|- E , X : ■

|- E
E |- A
X `notin` dom E
---------------- :: typ
|- E , X : A


defns 
J_d_inst :: '' ::=

defn 
E [ A ] ~~> B ::  :: d_inst :: 'd_inst__' by 

(X : B) in E
-------------- :: var
E [ X ] ~~> B

-------------- :: int
E [ INT ] ~~> INT

E [ A1 ] ~~> B1
E [ A2 ] ~~> B2
---------------- :: arr
E [ A1 -> A2 ] ~~> B1 -> B2

E [ A ] ~~> B
---------------- :: all
E [ ∀ X . A ] ~~> ∀ X . B

defns
J_d_sub :: '' ::=

defn
E |- c # A <: B :: :: d_sub :: 'd_sub__' by

|- E 
E [ A ] ~~> B
-------------- :: refl
E |- z # A <: B

|- E 
------------------- :: int
E |- ∞ # INT <: INT

|- E 
------------------- :: tvar
E |- ∞ # X <: X


E |- ∞ # A2 <: A1
E |- ∞ # B1 <: B2
------------------- :: arr1
E |- ∞ # A1 -> B1 <: A2 -> B2


E |- ∞ # A2 <: A1
E |- c # B1 <: B2
------------------- :: arr2
E |- S c # A1 -> B1 <: A2 -> B2

E , X : ■ |- ∞ # A1 <: A2
------------------- :: all
E |- ∞ # ∀ X . A1 <: ∀ X . A2

E |- C
E , X : C |- c # A <: B
------------------------ :: alll1
E |- S c # ∀ X . A <: B

E |- C
E , X : C |- c # A <: B
------------------------ :: alll2
E |- St c # ∀ X . A <: B

(X : B) in E
E |- c # B <: A
------------------------ :: varl
E |- c # X <: A


(X : B) in E
E |- c # A <: B
------------------------ :: varr
E |- c # A <: X